/*
 *  This file is part of the jasm project (http://code.google.com/p/jasm).
 *
 *  This file is licensed to you under the BSD License; You may not use
 *  this file except in compliance with the License. See the LICENSE.txt
 *  file distributed with this work for a copy of the License and information
 *  regarding copyright ownership.
 */
package jasm.gen.test;

import jasm.Argument;
import jasm.Assembler;
import jasm.AssemblyException;
import jasm.dis.DisassembledInstruction;
import jasm.dis.Disassembler;
import jasm.gen.ArgumentRange;
import jasm.gen.Assembly;
import jasm.gen.AssemblyTestComponent;
import jasm.gen.Parameter;
import jasm.gen.Template;
import jasm.util.SimpleTimer;
import jasm.util.WordWidth;
import jasm.util.collect.AppendableSequence;
import jasm.util.collect.ArrayListSequence;
import jasm.util.collect.Sequence;
import jasm.util.io.IndentWriter;
import jasm.util.program.ProgramError;
import jasm.util.program.ProgramWarning;
import jasm.util.program.Trace;
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.PrintWriter;
import java.io.PushbackInputStream;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

/**
 * A test framework for assemblers and disassemblers.
 * <p>
 * For a given instruction set, you can run the assembler
 * and the corresponding external GNU assembler (gas)
 * with the same set of arguments and compare the two generated byte arrays for equality.
 * This requires running on a platform on which the respective GNU assembler is installed
 * or configuring SSH to enable remote execution on a machine with the
 * respective GNU assembler installed (see {@link #setRemoteUserAndHost} for more details).
 * <p>
 * You can also run the assembler and then apply the disassembler to its result
 * and see if you end up with the same method and arguments that you assembled.
 * <p>
 * Both these tests can be combined in one pass.
 * <p>
 * A test run iterates over every template in the assembly, and for each of those:
 * - locates the assembler method in the raw assembler that corresponds to the current template
 * - generates a sequence of test argument lists based on the current template,
 * - performs the above described checks for each test argument list,
 *   invoking the located raw assembler method with it
 * <p>
 * A sequence of test argument lists is constructed by building the cross product of eligible argument values.
 * The eligible values of symbolic arguments comprise all values of the respective argument type.
 * The eligible values of numeric arguments better just be
 * a subset of the whole range defined by their argument type...
 * They are a handful of values representing all important boundary cases.
 * <p>
 * As with the original tester in the Klein assembly framework, this framework also features
 * "negative" tests, i.e. calls with illegal arguments that should be caught and reported.
 * The number of negative tests is far fewer than in the Klein assembly framework as the use
 * of static typing in this framework leaves far fewer opportunities to specify illegal arguments
 * without incurring a syntax or type error from javac. The majority of the remaining possibilities
 * for specifying illegal arguments lies in RISC assemblers' featuring immediate fields whose
 * ranges of legal values is not exactly described by a Java primitive type (e.g. int, short, char, etc).
 *
 * @author Bernd Mathiske
 * @author Doug Simon
 * @author Dave Ungar
 * @author Adam Spitz
 */
public abstract class AssemblyTester<Template_Type extends Template, DisassembledInstruction_Type extends DisassembledInstruction<Template_Type>> {

    private final Assembly<Template_Type> _assembly;
    private final WordWidth _addressWidth;
    private final EnumSet<AssemblyTestComponent> _components;

    protected AssemblyTester(Assembly<Template_Type> assembly, WordWidth addressWidth, EnumSet<AssemblyTestComponent> components) {
        _assembly = assembly;
        _addressWidth = addressWidth;
        _components = components;
        _tmpFilePrefix = _assembly.instructionSet().name().toLowerCase() + "-asmTest-";
    }

    public Assembly<Template_Type> assembly() {
        return _assembly;
    }

    public WordWidth addressWidth() {
        return _addressWidth;
    }

  private static void cleanupTempFiles(final String prefix) {
      if (prefix == null || prefix.length() == 0) {
          return;
      }
      try {
          final File tempFile = File.createTempFile(prefix, null);
          final File directory = tempFile.getParentFile();
          final FilenameFilter filter = new FilenameFilter() {
              public boolean accept(File dir, String name) {
                return !(prefix != null && prefix.length() > 0 && !name.startsWith(prefix));
              }
          };
          for (File file : directory.listFiles(filter)) {
              if (!file.delete()) {
                  ProgramWarning.message("could not delete temporary file: " + file.getAbsolutePath());
              }
          }
      } catch (IOException ioException) {
          ProgramWarning.message("could not delete temporary files");
      }
  }

  /**
     * Determines if a given set of arguments for a given template is legal.
     */
    protected abstract boolean isLegalArgumentList(Template_Type template, Sequence<Argument> arguments);

    protected abstract void assembleExternally(IndentWriter stream, Template_Type template, Sequence<Argument> argumentList, String label);

    private final String _tmpFilePrefix;
    private static final String SOURCE_EXTENSION = ".s";
    private static final String BINARY_EXTENSION = ".o";

    private boolean findExcludedDisassemblerTestArgument(Sequence<? extends Parameter> parameters, Sequence<Argument> arguments) {
        for (int i = 0; i < parameters.length(); i++) {
            if (parameters.get(i).excludedDisassemblerTestArguments().contains(arguments.get(i))) {
                return true;
            }
        }
        return false;
    }

    private boolean findExcludedExternalTestArgument(Sequence<? extends Parameter> parameters, Sequence<Argument> arguments) {
        for (int i = 0; i < parameters.length(); i++) {
            final Parameter parameter = parameters.get(i);
            if (parameter.excludedExternalTestArguments().contains(arguments.get(i))) {
                return true;
            }
            final ArgumentRange argumentRange = parameters.get(i).argumentRange();
            if (argumentRange != null && !argumentRange.includes(arguments.get(i))) {
                return true;
            }
        }
        return false;
    }

    protected final int _nNOPs = 10;

    private File createExternalSourceFile(Template_Type template, Iterator<Sequence<Argument>> argumentLists) throws IOException {
        final File sourceFile = File.createTempFile(_tmpFilePrefix + template.internalName(), SOURCE_EXTENSION);
        final IndentWriter stream = new IndentWriter(new PrintWriter(new BufferedWriter(new FileWriter(sourceFile))));
        stream.indent();
        for (int i = 0; i < _nNOPs; i++) {
            stream.println("nop");
        }
        createExternalSource(template, argumentLists, stream);
        for (int i = 0; i < _nNOPs; i++) {
            stream.println("nop");
        }
        stream.outdent();
        stream.close();
        return sourceFile;
    }

    private void createExternalSource(Template_Type template, Iterator<Sequence<Argument>> argumentLists, IndentWriter stream) {
        int i = 0;
        while (argumentLists.hasNext()) {
            final Sequence<Argument> argumentList = argumentLists.next();
            if (!findExcludedExternalTestArgument(template.parameters(), argumentList)) {
                final String label = "label" + i;
                assembleExternally(stream, template, argumentList, label);
            }
            ++i;
        }
    }

    protected abstract String assemblerCommand();

    private String _remoteAssemblerPath = "";

    /**
     * Sets the path of the directory on a remote machine containing the
     * {@link #assemblerCommand assembler command}. This is required as
     * some SSH installations only provide a very minimal environment
     * for remotely executed commands.
     *
     * @param path the absolute path to the directory containing the assembler executable (must not be null)
     */
    public void setRemoteAssemblerPath(String path) {
        assert path != null;
        _remoteAssemblerPath = path;
    }

    private String _remoteUserAndHost;

    /**
     * Sets the {@code user@host} string that will be used to execute the external
     * assembler on a remote host via SSH. If this value is not set or set to null, the
     * external assembler will be executed on the local machine.
     * <p>
     * Execution on a remote machine is performed via the use of the 'ssh' and 'scp'
     * native executables. As such, these executables must be on the user's path.
     * <p>
     * The SSH layer authenticates with the remote machine via public key authentication.
     * Configuring the local and remote machines for this authentication is described in
     * the ssh man page.
     * <p>
     * Here's the console output
     * captured while configuring user {@code dsimon} on machine {@code local}
     * to be able to remotely execute via SSH as user {@code dsimon} on machine
     * {@code remote}:
     * <p>
     * <table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC"><tr><td><pre><code>
     * [dsimon@local:~]$ <b>ssh-keygen -t dsa</b>
     * Generating public/private dsa key pair.
     * Enter file in which to save the key (/home/dsimon/.ssh/id_dsa):
     * Enter passphrase (empty for no passphrase):
     * Enter same passphrase again:
     * Your identification has been saved in /home/dsimon/.ssh/id_dsa.
     * Your public key has been saved in /home/dsimon/.ssh/id_dsa.pub.
     * The key fingerprint is:
     * 88:ec:17:53:7a:e1:35:bd:cf:cc:0a:bb:dd:ec:99:8d dsimon@local
     * [dsimon@local:~]$ <b>scp /home/dsimon/.ssh/id_dsa.pub dsimon@remote:</b>
     * Password:
     * id_dsa.pub                                                                    100%  617     0.6KB/s   00:00
     * [dsimon@local:~]$ ssh dsimon@remote
     * Password:
     * [dsimon@remote:~]$ <b>{@literal cat id_dsa.pub << .ssh/authorized_keys2}</b>
     * </code></pre></td></tr></table>
     *
     * @param remoteUserAndHost a {@code user@host} value denoting a machine that
     *        supports remote execution via SSH2 using public key authentication
     */
    public void setRemoteUserAndHost(String remoteUserAndHost) {
        _remoteUserAndHost = remoteUserAndHost;
    }

  private File createExternalBinaryFile(File sourceFile) throws IOException {
        try {
            final File binaryFile = new File(sourceFile.getPath().substring(0, sourceFile.getPath().length() - SOURCE_EXTENSION.length()) + BINARY_EXTENSION);
            if (_remoteUserAndHost != null) {

                // Copy input source to remote machine
                ExecUtil.exec("scp -C " + sourceFile.getAbsolutePath() + " " + _remoteUserAndHost + ":" + sourceFile.getName());

                // Execute assembler remotely
                ExecUtil.exec("ssh " + _remoteUserAndHost + " " + _remoteAssemblerPath + assemblerCommand() + " -o " + binaryFile.getName() + " " + sourceFile.getName());

                // Copy output binary to local machine
                ExecUtil.exec("scp -C " + _remoteUserAndHost + ":" + binaryFile.getName() + " " + binaryFile.getAbsolutePath());

                // Delete input source and output binary from remote machine
                ExecUtil.exec("ssh " + _remoteUserAndHost + " rm " + binaryFile.getName() + " " + sourceFile.getName());
            } else {
                ExecUtil.exec(assemblerCommand() + " " + sourceFile.getAbsolutePath() + " -o " + binaryFile.getAbsolutePath());
            }
            return binaryFile;
        } catch (InterruptedException e) {
            throw new InterruptedIOException(e.toString());
        }
    }

    protected abstract boolean readNop(InputStream stream) throws IOException;

    private boolean findStart(InputStream stream) throws IOException {
        while (stream.available() > 0) {
            if (readNop(stream)) {
                boolean found = true;
                for (int i = 1; i < _nNOPs; i++) {
                    if (!readNop(stream)) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Gets a string representation of the value and bitrange of each field in an assembled instruction.
     * For example, the returned value for an assembled Power PC {@code rldimi} instruction may be
     * {@code "opcd[0:5]=31{011111} fxm[12:19]=1{00000001} rs[6:10]=1{00001} bit_11[11:11]=-1{1} res_20[20:20]=0{0} xo_21_30[21:30]=144{0010010000} res_31[31:31]=0{0}"}.
     */
    protected abstract String disassembleFields(Template_Type template, byte[] assembledInstruction);

    protected abstract byte[] readExternalInstruction(PushbackInputStream stream, Template_Type template, byte[] internalBytes) throws IOException;

    protected abstract Assembler createTestAssembler();

    protected abstract Disassembler<Template_Type, DisassembledInstruction_Type> createTestDisassembler();

    /**
     * We use this more complicated comparison instead of 'Sequence.equals()',
     * because some arguments with different identity may have equal values,
     * e.g. 'FPStackRegister.ST.value() == FPStackRegister.ST_0.value()'.
     * It would have been much more clean to override 'equals()' of those argument classes,
     * but they are enums and Java predeclares methods inherited via Enum final :-(
     */
    private boolean equals(Sequence<Argument> arguments1, Sequence<Argument> arguments2) {
        if (arguments1.length() != arguments2.length()) {
            return false;
        }
        for (int i = 0; i < arguments1.length(); i++) {
            final Argument argument1 = arguments1.get(i);
            final Argument argument2 = arguments2.get(i);
            if (!argument1.equals(argument2)) {
                if (!areRelated(argument1.getClass(), argument2.getClass()) || argument1.asLong() != argument2.asLong()) {
                    return false;
                }
            }
        }
        return true;
    }

  private static boolean areRelated(Class<?> class1, Class<?> class2) {
        return class1.isAssignableFrom(class2) || class2.isAssignableFrom(class1);
    }

    private void createExternalSource(Template_Type template, IndentWriter stream) throws IOException, InterruptedException, AssemblyException {
        if (template.isExternallyTestable()) {
            final ArgumentListIterator<Template_Type> argumentLists = new ArgumentListIterator<Template_Type>(this, template, TestCaseLegality.LEGAL);
            createExternalSource(template, argumentLists, stream);
            Trace.line(2, "template: " + template + "  [" + argumentLists.iterations() + " test cases]");
        }
    }

    private void testDisassembler(Template_Type template, Sequence<Argument> argumentList, byte[] internalResult) throws IOException, AssemblyException {
        final BufferedInputStream disassemblyStream = new BufferedInputStream(new ByteArrayInputStream(internalResult));
        final Disassembler<Template_Type, DisassembledInstruction_Type> disassembler = createTestDisassembler();
        disassembler.setAbstractionPreference(template.instructionDescription().isSynthetic() ? Disassembler.AbstractionPreference.SYNTHETIC : Disassembler.AbstractionPreference.RAW);
        disassembler.setExpectedNumberOfArguments(argumentList.length());
        final Sequence<DisassembledInstruction_Type> disassembledInstructions = disassembler.scanOneInstruction(disassemblyStream);

        boolean matchFound = false;
        for (DisassembledInstruction_Type disassembledInstruction : disassembledInstructions) {
            matchFound = matchFound ||
                (disassembledInstruction.template().isEquivalentTo(template) &&
                 equals(disassembledInstruction.arguments(), argumentList) &&
                 Arrays.equals(disassembledInstruction.bytes(), internalResult));
        }

        if (disassemblyStream.available() != 0 || !matchFound) {
            System.err.println("internal disassembler test failed - " + disassembledInstructions.length() + " false matches found:");
            if (disassemblyStream.available() != 0) {
                System.err.print("extra bytes at end of disassembly stream:");
                for (final int b = disassemblyStream.read(); b != -1;) {
                    System.err.print(" 0x" + Integer.toHexString(b));
                }
                System.err.println();
            }
            int matchNumber = 1;
            for (DisassembledInstruction_Type disassembledInstruction : disassembledInstructions) {
                System.err.println();
                System.err.println("False match number " + matchNumber + ":");
                System.err.println("    assembled template: " + template);
                System.err.println(" disassembled template: " + disassembledInstruction.template());
                System.err.println("   assembled arguments: " + argumentList);
                System.err.println("disassembled arguments: " + disassembledInstruction.arguments());
                System.err.println("       assembled bytes: " + DisassembledInstruction.toHexString(internalResult));
                System.err.println("    disassembled bytes: " + DisassembledInstruction.toHexString(disassembledInstruction.bytes()));
                ++matchNumber;
            }
            ProgramError.unexpected("mismatch between internal assembler and disassembler");
        }
        disassemblyStream.close();
    }

    private final SimpleTimer _timer = new SimpleTimer();

    private void testTemplate(final Template_Type template) throws IOException, InterruptedException, AssemblyException {
        final boolean testingExternally = _components.contains(AssemblyTestComponent.EXTERNAL_ASSEMBLER) && template.isExternallyTestable();

        // Process legal test cases
        final ArgumentListIterator<Template_Type> argumentLists =
            new ArgumentListIterator<Template_Type>(this, template, TestCaseLegality.LEGAL);
        ProgramError.check(argumentLists.hasNext(), "no test cases were generated for template: " + template);
        _timer.reset();
        File binaryFile = null;
        PushbackInputStream externalInputStream = null;
        if (testingExternally) {
          cleanupTempFiles(_tmpFilePrefix);
          final File sourceFile;
          try {
            _timer.start("src");
            sourceFile = createExternalSourceFile(template, argumentLists);
          } finally {
            _timer.stop();
          }
          try {
            _timer.start("gas");
            binaryFile = createExternalBinaryFile(sourceFile);
          } finally {
            _timer.stop();
          }
            externalInputStream = new PushbackInputStream(new BufferedInputStream(new FileInputStream(binaryFile)));
            if (!findStart(externalInputStream)) {
                ProgramError.unexpected("could not find start sequence in: " + binaryFile.getAbsolutePath());
            }
        }

        int testCaseNumber = 0;
        for (final ArgumentListIterator<Template_Type> iterator =
            new ArgumentListIterator<Template_Type>(this, template, TestCaseLegality.LEGAL); iterator.hasNext();) {
            final Sequence<Argument> argumentList = iterator.next();
            final Assembler assembler = createTestAssembler();

            final byte[] internalResult;
            try {
              _timer.start("asm");
              assembly().assemble(assembler, template, argumentList);
              internalResult = assembler.toByteArray();
            } finally {
              _timer.stop();
            }

            Trace.line(3, "assembleInternally: " + assembly().createMethodCallString(template, argumentList) + " = " + DisassembledInstruction.toHexString(internalResult));
            if (_components.contains(AssemblyTestComponent.DISASSEMBLER) && template.isDisassemblable() &&
                    !findExcludedDisassemblerTestArgument(template.parameters(), argumentList)) {

              try {
                _timer.start("dis");
                try {
                  testDisassembler(template, argumentList, internalResult);
                } catch (IOException e) {
                  throw new AssemblyException(e.toString());
                }
              } finally {
                _timer.stop();
              }
            }

              if (testingExternally && !findExcludedExternalTestArgument(template.parameters(), argumentList)) {
                final byte[] externalResult = readExternalInstruction(externalInputStream, template, internalResult);
                for (int i = 0; i < externalResult.length; i++) {
                    if (internalResult[i] != externalResult[i]) {
                        System.err.println("external assembler test case " + testCaseNumber + " failed for template: " + template);
                        System.err.println("arguments: " + argumentList);
                        System.err.println("internal result: " + DisassembledInstruction.toHexString(internalResult));
                        System.err.println("external result: " + DisassembledInstruction.toHexString(externalResult));
                        System.err.println("internal result fields: " + disassembleFields(template, internalResult));
                        System.err.println("external result fields: " + disassembleFields(template, externalResult));
                        ProgramError.unexpected("mismatch between internal and external assembler");
                    }
                }
            }
            ++testCaseNumber;
        }

        // Process illegal test cases
        int illegalTestCaseNumber = 0;
        final Set<String> uniqueExceptionMessages = new HashSet<String>();
        for (TestCaseLegality testCaseLegality : new TestCaseLegality[]{TestCaseLegality.ILLEGAL_BY_CONSTRAINT, TestCaseLegality.ILLEGAL_BY_ARGUMENT}) {
            for (final ArgumentListIterator<Template_Type> iterator = new ArgumentListIterator<Template_Type>(this, template, testCaseLegality); iterator.hasNext();) {
                final Sequence<Argument> argumentList = iterator.next();
                final Assembler assembler = createTestAssembler();
                try {
                    assembly().assemble(assembler, template, argumentList);
                } catch (IllegalArgumentException e) {
                    final String exceptionMessage = e.getMessage();
                    uniqueExceptionMessages.add(exceptionMessage);
                    ++illegalTestCaseNumber;
                    continue;
                }

                System.err.println("illegal assembler test case " + illegalTestCaseNumber + " did not throw an exception for template: " + template);
                System.err.println("arguments: " + argumentList);
                ProgramError.unexpected("failed illegal test case");
                ++illegalTestCaseNumber;
            }
        }

      Trace.line(2, "template: " + template + "  [" + testCaseNumber + " test cases, " +
                      "timings: " + getTimingString() + ", " +
                      illegalTestCaseNumber + " illegal test cases]");
        for (String message : uniqueExceptionMessages) {
            Trace.line(2, "    caught expected IllegalArgumentException: " + message);
        }
        if (testingExternally) {
            for (int i = 0; i < _nNOPs; i++) {
                if (!readNop(externalInputStream)) {
                    ProgramError.unexpected("end pattern missing in: " + binaryFile.getAbsolutePath());
                }
            }
            externalInputStream.close();
        }
    }

  private StringBuilder getTimingString() {
    final Iterator<Entry<String, Long>> iterator = _timer.flatTimes().iterator();
    boolean hasNext = iterator.hasNext();
    final StringBuilder buf = new StringBuilder();
    while (hasNext) {
      final Entry<String, Long> element = iterator.next();
      final String string = element.getKey() + "=" + element.getValue() + "ms";
      buf.append(string);
      hasNext = iterator.hasNext();
      if (hasNext) {
        buf.append(", ");
      }
    }
    return buf;
  }

  private String _templatePattern;

    /**
     * Sets the pattern that restricts which templates are tested.
     *
     * @param pattern if non-null, only templates whose {@link Template#internalName() name} contains
     *                {@code pattern} as a substring are tested
     */
    public void setTemplatePattern(String pattern) {
        _templatePattern = pattern;
    }

    public void run(int startTemplateSerial, int endTemplateSerial, boolean onlyCreateExternalSource) {
        File sourceFile = null;
        IndentWriter stream = null;
        final AppendableSequence<Template_Type> errors = new ArrayListSequence<Template_Type>();

        try {
            for (Template_Type template : assembly().templates()) {
                if (template.serial() > endTemplateSerial) {
                    break;
                }
                Trace.on(2);
                try {
                    if (template.serial() >= startTemplateSerial) {
                        if (_templatePattern == null || template.internalName().contains(_templatePattern)) {
                            if (onlyCreateExternalSource) {
                                if (sourceFile == null) {
                                    sourceFile = new File(_tmpFilePrefix + "all" + SOURCE_EXTENSION);
                                    stream = new IndentWriter(new PrintWriter(new BufferedWriter(new FileWriter(sourceFile))));
                                    stream.indent();
                                }
                                createExternalSource(template, stream);
                            } else {
                                testTemplate(template);
                            }
                        }
                    }
                } catch (Throwable throwable) {
                    Trace.line(2, "template: " + template + "  failed testing");
                    throwable.printStackTrace();
                    errors.append(template);
                }
            }
        } finally {
            if (onlyCreateExternalSource && stream != null) {
                stream.close();
            }
        }

        if (!errors.isEmpty()) {
            System.err.println("Errors occurred when testing the following templates:");
            for (Template_Type template : errors) {
                System.err.println("    " + template);
            }
            ProgramError.unexpected(errors.length() + " templates failed testing: see previous stack dumps in test output");
        }
    }

}
