/*
 *  This file is part of the jasm project (http://code.google.com/p/jasm).
 *
 *  This file is licensed to you under the BSD License; You may not use
 *  this file except in compliance with the License. See the LICENSE.txt
 *  file distributed with this work for a copy of the License and information
 *  regarding copyright ownership.
 */
package jasm.gen;

import com.sun.max.collect.AppendableSequence;
import com.sun.max.collect.ArrayListSequence;
import com.sun.max.collect.ArraySequence;
import com.sun.max.collect.FilterIterator;
import com.sun.max.collect.Sequence;
import com.sun.max.io.IndentWriter;
import com.sun.max.io.ReadableSource;
import com.sun.max.lang.StaticLoophole;
import com.sun.max.program.ProgramError;
import com.sun.max.program.ProgramWarning;
import com.sun.max.program.Trace;
import jasm.util.SimpleTimer;
import jasm.Argument;
import jasm.Assembler;
import jasm.AssemblyException;
import jasm.dis.DisassembledInstruction;
import jasm.dis.Disassembler;
import jasm.util.WordWidth;
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PushbackInputStream;
import java.io.FileOutputStream;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Writer;
import java.io.Closeable;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * A test framework for assemblers and disassemblers.
 * <p>
 * For a given instruction set, you can run the assembler
 * and the corresponding external GNU assembler (gas)
 * with the same set of arguments and compare the two generated byte arrays for equality.
 * This requires running on a platform on which the respective GNU assembler is installed
 * or configuring SSH to enable remote execution on a machine with the
 * respective GNU assembler installed (see {@link #setRemoteUserAndHost} for more details).
 * <p>
 * You can also run the assembler and then apply the disassembler to its result
 * and see if you end up with the same method and arguments that you assembled.
 * <p>
 * Both these tests can be combined in one pass.
 * <p>
 * A test run iterates over every template in the assembly, and for each of those:
 * - locates the assembler method in the raw assembler that corresponds to the current template
 * - generates a sequence of test argument lists based on the current template,
 * - performs the above described checks for each test argument list,
 *   invoking the located raw assembler method with it
 * <p>
 * A sequence of test argument lists is constructed by building the cross product of eligible argument values.
 * The eligible values of symbolic arguments comprise all values of the respective argument type.
 * The eligible values of numeric arguments better just be
 * a subset of the whole range defined by their argument type...
 * They are a handful of values representing all important boundary cases.
 * <p>
 * As with the original tester in the Klein assembly framework, this framework also features
 * "negative" tests, i.e. calls with illegal arguments that should be caught and reported.
 * The number of negative tests is far fewer than in the Klein assembly framework as the use
 * of static typing in this framework leaves far fewer opportunities to specify illegal arguments
 * without incurring a syntax or type error from javac. The majority of the remaining possibilities
 * for specifying illegal arguments lies in RISC assemblers' featuring immediate fields whose
 * ranges of legal values is not exactly described by a Java primitive type (e.g. int, short, char, etc).
 *
 * @author Bernd Mathiske
 * @author Doug Simon
 * @author Dave Ungar
 * @author Adam Spitz
 */
public abstract class AssemblyTester<Template_Type extends Template, DisassembledInstruction_Type extends DisassembledInstruction<Template_Type>> {

    private final Assembly<Template_Type> _assembly;
    private final WordWidth _addressWidth;
    private final EnumSet<AssemblyTestComponent> _components;

    protected AssemblyTester(Assembly<Template_Type> assembly, WordWidth addressWidth, EnumSet<AssemblyTestComponent> components) {
        super();
        _assembly = assembly;
        _addressWidth = addressWidth;
        _components = components;
        _tmpFilePrefix = _assembly.instructionSet().name().toLowerCase() + "-asmTest-";
    }

    public Assembly<Template_Type> assembly() {
        return _assembly;
    }

    public WordWidth addressWidth() {
        return _addressWidth;
    }

  private static void cleanupTempFiles(final String prefix) {
      if (prefix == null || prefix.length() == 0) {
          return;
      }
      try {
          final File tempFile = File.createTempFile(prefix, null);
          final File directory = tempFile.getParentFile();
          final FilenameFilter filter = new FilenameFilter() {
              public boolean accept(File dir, String name) {
                return !(prefix != null && prefix.length() > 0 && !name.startsWith(prefix));
              }
          };
          for (File file : directory.listFiles(filter)) {
              if (!file.delete()) {
                  ProgramWarning.message("could not delete temporary file: " + file.getAbsolutePath());
              }
          }
      } catch (IOException ioException) {
          ProgramWarning.message("could not delete temporary files");
      }
  }

  static void copy(File from, File to) throws IOException {
    InputStream inputStream = null;
    OutputStream outputStream = null;
    try {
      inputStream = new FileInputStream(from);
      outputStream = new FileOutputStream(to);
      copy(inputStream, outputStream);
    } finally {
      if (inputStream != null) {
        inputStream.close();
      }
      if (outputStream != null) {
        outputStream.close();
      }
    }
  }

  /**
   * Updates the generated content part of a file. A generated content part is delimited by a line containing
   * only {@code start} and a line containing only {@code end}. If the given file already exists and
   * has these delimiters, the content between these lines is compared with {@code content} and replaced
   * if it is different. If the file does not exist, a new file is created with {@code content} surrounded
   * by the specified delimiters. If the file exists and does not currently have the specified delimiters, an
   * IOException is thrown.
   *
   * @return true if the file was modified or created
   */
  public static boolean markGeneratedContent(File file, ReadableSource content) throws IOException {
    final String start = "// START GENERATED CONTENT";
    final String end = "// END GENERATED CONTENT";
    if (!file.exists()) {
      final PrintWriter printWriter = new PrintWriter(new BufferedWriter(new FileWriter(file)));
      try {
        final Reader reader = content.reader();
        try {
          copy(reader, printWriter);
          printWriter.println(end);
        } finally {
          reader.close();
        }
      } finally {
        printWriter.close();
      }
      return true;
    }

    final File tempFile = File.createTempFile(file.getName() + ".", null);
    PrintWriter printWriter = null;
    BufferedReader contentReader = null;
    BufferedReader existingFileReader = null;
    try {
      printWriter = new PrintWriter(new BufferedWriter(new FileWriter(tempFile)));
      contentReader = (BufferedReader) content.reader();
      existingFileReader = new BufferedReader(new FileReader(file));

      // Copy existing file up to generated content opening delimiter
      String line;
      while ((line = existingFileReader.readLine()) != null) {
        printWriter.println(line);
        if (line.equals(start)) {
          break;
        }
      }

      if (line == null) {
        throw new IOException("generated content starting delimiter not found in existing file: " + file);
      }

      boolean changed = false;
      boolean seenEnd = false;

      // Copy new content, noting if it differs from existing generated content
      while ((line = contentReader.readLine()) != null) {
        if (!seenEnd) {
          final String existingLine = existingFileReader.readLine();
          if (existingLine != null) {
            if (end.equals(existingLine)) {
              seenEnd = true;
              changed = true;
            } else {
              changed = changed || !line.equals(existingLine);
            }
          }
        }
        printWriter.println(line);
      }

      // Find the generated content closing delimiter
      if (!seenEnd) {
        while ((line = existingFileReader.readLine()) != null) {
          if (line.equals(end)) {
            seenEnd = true;
            break;
          }
          changed = true;
        }
        if (!seenEnd) {
          throw new IOException("generated content ending delimiter not found in existing file: " + file);
        }
      }
      printWriter.println(end);

      // Copy existing file after generated content closing delimiter
      while ((line = existingFileReader.readLine()) != null) {
        printWriter.println(line);
      }

      printWriter.close();
      printWriter = null;
      existingFileReader.close();
      existingFileReader = null;

      if (changed) {
        copy(tempFile, file);
        return true;
      }
      return false;
    } finally {
      quietClose(printWriter);
      quietClose(contentReader);
      quietClose(existingFileReader);
      if (!tempFile.delete()) {
        throw new IOException("could not delete file for update: " + file);
      }
    }
  }

  static void copy(Reader reader, Writer writer) throws IOException {
    final char[] buffer = new char[8192];
    int count;
    while ((count = reader.read(buffer, 0, buffer.length)) > 0) {
      writer.write(buffer, 0, count);
    }
    writer.flush();
  }

  static void quietClose(Closeable closeable) {
    if (closeable != null) {
      try {
        closeable.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

  static void copy(InputStream inputStream, OutputStream outputStream) throws IOException {
    final byte[] buffer = new byte[8192];
    int count;
    while ((count = inputStream.read(buffer, 0, buffer.length)) > 0) {
      outputStream.write(buffer, 0, count);
    }
    outputStream.flush();
  }

  public static Redirector redirect(Process process, InputStream inputStream, OutputStream outputStream, String name,
                                    int maxLines) {
    return new Redirector(process, inputStream, outputStream, name, maxLines);
  }

  public static Redirector redirect(Process process, InputStream inputStream, OutputStream outputStream, String name) {
    return redirect(process, inputStream, outputStream, name, Integer.MAX_VALUE);
  }

  enum TestCaseLegality {
            LEGAL, ILLEGAL_BY_CONSTRAINT, ILLEGAL_BY_ARGUMENT
    }

    /**
     * This is an iterator over a (lazily generated) selection of test cases for a given template.
     * Using an iterator means that each test case is generated as needed and does not
     * use up memory longer than necessary. This helps prevent out of memory errors
     * for templates where the number of test cases can be very large.
     *
     * It is important to note that the value returned by {@link #next()} is only valid
     * until {@code next()} is called again. That is, the same <code>Sequence<Argument></code>
     * object is returned by each call to {@code next()}, only its contents have changed.
     *
     * @author Doug Simon
     */
    class ArgumentListIterator implements Iterator<Sequence<Argument>> {

        private final Template_Type _template;
        private final Parameter[] _parameters;
        private final Iterator<? extends Argument>[] _testArgumentIterators;
        private final int _count;
        private final Argument[] _arguments;
        private final Sequence<Argument> _next;
        private final TestCaseLegality _testCaseLegality;

        private boolean _hasNext;
        private boolean _advanced;
        private int _iterations;

        /**
         * Creates an iterator over a set of test cases for a given template.
         */
        ArgumentListIterator(Template_Type template, TestCaseLegality testCaseLegality) {
            _testCaseLegality  = testCaseLegality;
            _template = template;
            _parameters = Sequence.Static.toArray(template.parameters(), Parameter.class);
            _count = template.parameters().length();
            _arguments = new Argument[_count];
            _next = new ArraySequence<Argument>(_arguments);
            _testArgumentIterators = StaticLoophole.cast(new Iterator[_count]);
            _hasNext = advance();
        }

        /**
         * @return the number of times {@link #next} has been invoked on this iterator without throwing a NoSuchElementException.
         */
        public int iterations() {
            return _iterations;
        }

        public boolean hasNext() {
            if (_count == 0) {
                return _testCaseLegality == TestCaseLegality.LEGAL && _iterations == 0;
            }
            if (!_advanced) {
                _hasNext = advance();
            }
            return _hasNext;
        }

        /**
         * The returned sequence is only valid for a single iteration and so should be copied
         * if needed after this iteration.
         */
        public Sequence<Argument> next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            _advanced = false;
            ++_iterations;
            return _next;
        }

        /**
         * Advances this iterator to the next argument list.
         *
         * @return true if the iterator could advance
         */
        private boolean advance() {
            assert !_advanced;
            _advanced = true;
            if (_count == 0) {
                return _testCaseLegality == TestCaseLegality.LEGAL;
            }
            boolean result;
            do {
                result = advance0();
            } while (result && isLegalArgumentList(_template, _next) != (_testCaseLegality == TestCaseLegality.LEGAL));
            return result;
        }

        /**
         * Advances the test argument iterator for parameter {@code i}.
         *
         * @return true if the iterator could advance
         */
        private boolean advanceArgumentFor(int i) {
            if (_testArgumentIterators[i].hasNext()) {
                _arguments[i] = _testArgumentIterators[i].next();
                return true;
            }
            return false;
        }

        /**
         * Advances this iterator to the next (potentially invalid) argument list.
         *
         * @return true if the iterator could advance
         */
        private boolean advance0() {
            for (int i = _count - 1; i >= 0; --i) {
                if (_testArgumentIterators[i] != null) {
                    if (advanceArgumentFor(i)) {
                        return true;
                    }
                    if (i == 0) {
                        return false;
                    }
                }

                // Reset iterator over test arguments of the i'th parameter
                final Parameter parameter = _parameters[i];
                if (_testCaseLegality != TestCaseLegality.ILLEGAL_BY_ARGUMENT) {
                    final Iterable<? extends Argument> arguments = parameter.getLegalTestArguments();
                    final ArgumentRange argumentRange = parameter.argumentRange();
                    if (argumentRange == null || !argumentRange.appliesInternally()) {
                        _testArgumentIterators[i] = arguments.iterator();
                    } else {
                        _testArgumentIterators[i] = new FilterIterator<Argument>(arguments.iterator(), new FilterIterator.Predicate<Argument>() {
                            public boolean evaluate(Argument argument) {
                                return argumentRange.includes(argument);
                            }
                        });
                    }
                } else {
                    Iterator<? extends Argument> iterator = parameter.getIllegalTestArguments().iterator();
                    if (!iterator.hasNext()) {
                        // For parameters that have no illegal values (e.g. a symbolic register parameter)
                        // at least one argument must be returned otherwise illegal test cases where only
                        // one argument is illegal will never be returned by this iterator.
                        //
                        // Instead of iterating over all the legal arguments for such a parameter, only
                        // the last legal value is used. This involves retrieving the iterator twice but
                        // that's much cheaper than many more redundant iterations.
                        iterator = parameter.getLegalTestArguments().iterator();
                      int count = 0;
                      while (iterator.hasNext()) {
                          ++count;
                          ((Iterator) iterator).next();
                      }
                      int n = count;
                        iterator = parameter.getLegalTestArguments().iterator();
                        while (n-- > 1) {
                            iterator.next();
                        }
                        assert iterator.hasNext();
                        _testArgumentIterators[i] = iterator;
                    } else {
                        _testArgumentIterators[i] = iterator;
                    }
                }
                if (!advanceArgumentFor(i)) {
                    return false;
                }
            }
            return true;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * Determines if a given set of arguments for a given template is legal.
     */
    protected abstract boolean isLegalArgumentList(Template_Type template, Sequence<Argument> arguments);

    protected abstract void assembleExternally(IndentWriter stream, Template_Type template, Sequence<Argument> argumentList, String label);

    private final String _tmpFilePrefix;
    private static final String SOURCE_EXTENSION = ".s";
    private static final String BINARY_EXTENSION = ".o";

    private boolean findExcludedDisassemblerTestArgument(Sequence<? extends Parameter> parameters, Sequence<Argument> arguments) {
        for (int i = 0; i < parameters.length(); i++) {
            if (parameters.get(i).excludedDisassemblerTestArguments().contains(arguments.get(i))) {
                return true;
            }
        }
        return false;
    }

    private boolean findExcludedExternalTestArgument(Sequence<? extends Parameter> parameters, Sequence<Argument> arguments) {
        for (int i = 0; i < parameters.length(); i++) {
            final Parameter parameter = parameters.get(i);
            if (parameter.excludedExternalTestArguments().contains(arguments.get(i))) {
                return true;
            }
            final ArgumentRange argumentRange = parameters.get(i).argumentRange();
            if (argumentRange != null && !argumentRange.includes(arguments.get(i))) {
                return true;
            }
        }
        return false;
    }

    protected final int _nNOPs = 10;

    private File createExternalSourceFile(Template_Type template, Iterator<Sequence<Argument>> argumentLists) throws IOException {
        final File sourceFile = File.createTempFile(_tmpFilePrefix + template.internalName(), SOURCE_EXTENSION);
        final IndentWriter stream = new IndentWriter(new PrintWriter(new BufferedWriter(new FileWriter(sourceFile))));
        stream.indent();
        for (int i = 0; i < _nNOPs; i++) {
            stream.println("nop");
        }
        createExternalSource(template, argumentLists, stream);
        for (int i = 0; i < _nNOPs; i++) {
            stream.println("nop");
        }
        stream.outdent();
        stream.close();
        return sourceFile;
    }

    private void createExternalSource(Template_Type template, Iterator<Sequence<Argument>> argumentLists, IndentWriter stream) {
        int i = 0;
        while (argumentLists.hasNext()) {
            final Sequence<Argument> argumentList = argumentLists.next();
            if (!findExcludedExternalTestArgument(template.parameters(), argumentList)) {
                final String label = "label" + i;
                assembleExternally(stream, template, argumentList, label);
            }
            ++i;
        }
    }

    protected abstract String assemblerCommand();

    private String _remoteAssemblerPath = "";

    /**
     * Sets the path of the directory on a remote machine containing the
     * {@link #assemblerCommand assembler command}. This is required as
     * some SSH installations only provide a very minimal environment
     * for remotely executed commands.
     *
     * @param path the absolute path to the directory containing the assembler executable (must not be null)
     */
    public void setRemoteAssemblerPath(String path) {
        assert path != null;
        _remoteAssemblerPath = path;
    }

    private String _remoteUserAndHost;

    /**
     * Sets the {@code user@host} string that will be used to execute the external
     * assembler on a remote host via SSH. If this value is not set or set to null, the
     * external assembler will be executed on the local machine.
     * <p>
     * Execution on a remote machine is performed via the use of the 'ssh' and 'scp'
     * native executables. As such, these executables must be on the user's path.
     * <p>
     * The SSH layer authenticates with the remote machine via public key authentication.
     * Configuring the local and remote machines for this authentication is described in
     * the ssh man page.
     * <p>
     * Here's the console output
     * captured while configuring user {@code dsimon} on machine {@code local}
     * to be able to remotely execute via SSH as user {@code dsimon} on machine
     * {@code remote}:
     * <p>
     * <table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC"><tr><td><pre><code>
     * [dsimon@local:~]$ <b>ssh-keygen -t dsa</b>
     * Generating public/private dsa key pair.
     * Enter file in which to save the key (/home/dsimon/.ssh/id_dsa):
     * Enter passphrase (empty for no passphrase):
     * Enter same passphrase again:
     * Your identification has been saved in /home/dsimon/.ssh/id_dsa.
     * Your public key has been saved in /home/dsimon/.ssh/id_dsa.pub.
     * The key fingerprint is:
     * 88:ec:17:53:7a:e1:35:bd:cf:cc:0a:bb:dd:ec:99:8d dsimon@local
     * [dsimon@local:~]$ <b>scp /home/dsimon/.ssh/id_dsa.pub dsimon@remote:</b>
     * Password:
     * id_dsa.pub                                                                    100%  617     0.6KB/s   00:00
     * [dsimon@local:~]$ ssh dsimon@remote
     * Password:
     * [dsimon@remote:~]$ <b>{@literal cat id_dsa.pub << .ssh/authorized_keys2}</b>
     * </code></pre></td></tr></table>
     *
     * @param remoteUserAndHost a {@code user@host} value denoting a machine that
     *        supports remote execution via SSH2 using public key authentication
     */
    public void setRemoteUserAndHost(String remoteUserAndHost) {
        _remoteUserAndHost = remoteUserAndHost;
    }

    /**
     * Executes a command in a subprocess redirecting the standard streams of the
     * subprocess to/from the standard streams of the current process.
     *
     * @param command  the command line to execute
     */
    private void exec(String command) throws IOException, InterruptedException {
        exec(command, System.out, System.err, System.in);
    }

    /**
     * Executes a command in a subprocess redirecting the standard streams of the
     * subprocess to/from the supplied streams.
     *
     * @param command  the command line to execute
     * @param out   the stream to which standard output will be directed
     * @param err   the stream to which standard error output will be directed
     * @param in    the stream from which standard input will be read
     */
    private void exec(String command, OutputStream out, OutputStream err, InputStream in) throws IOException, InterruptedException {
        final Process process = Runtime.getRuntime().exec(command);
        try {
            final Redirector stderr = redirect(process, process.getErrorStream(), err, command + " [stderr]", 50);
            final Redirector stdout = redirect(process, process.getInputStream(), out, command + " [stdout]");
            final Redirector stdin = redirect(process, in, process.getOutputStream(), command + " [stdin]");
            final int exitValue = process.waitFor();
            stderr.close();
            stdout.close();
            stdin.close();
            if (exitValue != 0) {
                ProgramError.unexpected("execution of command failed: " + command + " [exit code = " + exitValue + "]");
            }
        } finally {
            process.destroy();
        }
    }

    private File createExternalBinaryFile(File sourceFile) throws IOException {
        try {
            final File binaryFile = new File(sourceFile.getPath().substring(0, sourceFile.getPath().length() - SOURCE_EXTENSION.length()) + BINARY_EXTENSION);
            if (_remoteUserAndHost != null) {

                // Copy input source to remote machine
                exec("scp -C " + sourceFile.getAbsolutePath() + " " + _remoteUserAndHost + ":" + sourceFile.getName());

                // Execute assembler remotely
                exec("ssh " + _remoteUserAndHost + " " + _remoteAssemblerPath + assemblerCommand() + " -o " + binaryFile.getName() + " " + sourceFile.getName());

                // Copy output binary to local machine
                exec("scp -C " + _remoteUserAndHost + ":" + binaryFile.getName() + " " + binaryFile.getAbsolutePath());

                // Delete input source and output binary from remote machine
                exec("ssh " + _remoteUserAndHost + " rm " + binaryFile.getName() + " " + sourceFile.getName());
            } else {
                exec(assemblerCommand() + " " + sourceFile.getAbsolutePath() + " -o " + binaryFile.getAbsolutePath());
            }
            return binaryFile;
        } catch (InterruptedException e) {
            throw new InterruptedIOException(e.toString());
        }
    }

    protected abstract boolean readNop(InputStream stream) throws IOException;

    private boolean findStart(InputStream stream) throws IOException {
        while (stream.available() > 0) {
            if (readNop(stream)) {
                boolean found = true;
                for (int i = 1; i < _nNOPs; i++) {
                    if (!readNop(stream)) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Gets a string representation of the value and bitrange of each field in an assembled instruction.
     * For example, the returned value for an assembled Power PC {@code rldimi} instruction may be
     * {@code "opcd[0:5]=31{011111} fxm[12:19]=1{00000001} rs[6:10]=1{00001} bit_11[11:11]=-1{1} res_20[20:20]=0{0} xo_21_30[21:30]=144{0010010000} res_31[31:31]=0{0}"}.
     */
    protected abstract String disassembleFields(Template_Type template, byte[] assembledInstruction);

    protected abstract byte[] readExternalInstruction(PushbackInputStream stream, Template_Type template, byte[] internalBytes) throws IOException;

    protected abstract Assembler createTestAssembler();

    protected abstract Disassembler<Template_Type, DisassembledInstruction_Type> createTestDisassembler();

    /**
     * We use this more complicated comparison instead of 'Sequence.equals()',
     * because some arguments with different identity may have equal values,
     * e.g. 'FPStackRegister.ST.value() == FPStackRegister.ST_0.value()'.
     * It would have been much more clean to override 'equals()' of those argument classes,
     * but they are enums and Java predeclares methods inherited via Enum final :-(
     */
    private boolean equals(Sequence<Argument> arguments1, Sequence<Argument> arguments2) {
        if (arguments1.length() != arguments2.length()) {
            return false;
        }
        for (int i = 0; i < arguments1.length(); i++) {
            final Argument argument1 = arguments1.get(i);
            final Argument argument2 = arguments2.get(i);
            if (!argument1.equals(argument2)) {
                if (!areRelated(argument1.getClass(), argument2.getClass()) || argument1.asLong() != argument2.asLong()) {
                    return false;
                }
            }
        }
        return true;
    }

  private static boolean areRelated(Class<?> class1, Class<?> class2) {
        return class1.isAssignableFrom(class2) || class2.isAssignableFrom(class1);
    }

    private void createExternalSource(Template_Type template, IndentWriter stream) throws IOException, InterruptedException, AssemblyException {
        if (template.isExternallyTestable()) {
            final ArgumentListIterator argumentLists = new ArgumentListIterator(template, TestCaseLegality.LEGAL);
            createExternalSource(template, argumentLists, stream);
            Trace.line(2, "template: " + template + "  [" + argumentLists.iterations() + " test cases]");
        }
    }

    private void testDisassembler(Template_Type template, Sequence<Argument> argumentList, byte[] internalResult) throws IOException, AssemblyException {
        final BufferedInputStream disassemblyStream = new BufferedInputStream(new ByteArrayInputStream(internalResult));
        final Disassembler<Template_Type, DisassembledInstruction_Type> disassembler = createTestDisassembler();
        disassembler.setAbstractionPreference(template.instructionDescription().isSynthetic() ? Disassembler.AbstractionPreference.SYNTHETIC : Disassembler.AbstractionPreference.RAW);
        disassembler.setExpectedNumberOfArguments(argumentList.length());
        final Sequence<DisassembledInstruction_Type> disassembledInstructions = disassembler.scanOneInstruction(disassemblyStream);

        boolean matchFound = false;
        for (DisassembledInstruction_Type disassembledInstruction : disassembledInstructions) {
            matchFound = matchFound ||
                (disassembledInstruction.template().isEquivalentTo(template) &&
                 equals(disassembledInstruction.arguments(), argumentList) &&
                 Arrays.equals(disassembledInstruction.bytes(), internalResult));
        }

        if (disassemblyStream.available() != 0 || !matchFound) {
            System.err.println("internal disassembler test failed - " + disassembledInstructions.length() + " false matches found:");
            if (disassemblyStream.available() != 0) {
                System.err.print("extra bytes at end of disassembly stream:");
                for (final int b = disassemblyStream.read(); b != -1;) {
                    System.err.print(" 0x" + Integer.toHexString(b));
                }
                System.err.println();
            }
            int matchNumber = 1;
            for (DisassembledInstruction_Type disassembledInstruction : disassembledInstructions) {
                System.err.println();
                System.err.println("False match number " + matchNumber + ":");
                System.err.println("    assembled template: " + template);
                System.err.println(" disassembled template: " + disassembledInstruction.template());
                System.err.println("   assembled arguments: " + argumentList);
                System.err.println("disassembled arguments: " + disassembledInstruction.arguments());
                System.err.println("       assembled bytes: " + DisassembledInstruction.toHexString(internalResult));
                System.err.println("    disassembled bytes: " + DisassembledInstruction.toHexString(disassembledInstruction.bytes()));
                ++matchNumber;
            }
            ProgramError.unexpected("mismatch between internal assembler and disassembler");
        }
        disassemblyStream.close();
    }

    private final SimpleTimer _timer = new SimpleTimer();

    private void testTemplate(final Template_Type template) throws IOException, InterruptedException, AssemblyException {
        final boolean testingExternally = _components.contains(AssemblyTestComponent.EXTERNAL_ASSEMBLER) && template.isExternallyTestable();

        // Process legal test cases
        final ArgumentListIterator argumentLists = new ArgumentListIterator(template, TestCaseLegality.LEGAL);
        ProgramError.check(argumentLists.hasNext(), "no test cases were generated for template: " + template);
        _timer.reset();
        File binaryFile = null;
        PushbackInputStream externalInputStream = null;
        if (testingExternally) {
          cleanupTempFiles(_tmpFilePrefix);
          final File sourceFile;
          try {
            _timer.start("src");
            sourceFile = createExternalSourceFile(template, argumentLists);
          } finally {
            _timer.stop();
          }
          try {
            _timer.start("gas");
            binaryFile = createExternalBinaryFile(sourceFile);
          } finally {
            _timer.stop();
          }
            externalInputStream = new PushbackInputStream(new BufferedInputStream(new FileInputStream(binaryFile)));
            if (!findStart(externalInputStream)) {
                ProgramError.unexpected("could not find start sequence in: " + binaryFile.getAbsolutePath());
            }
        }

        int testCaseNumber = 0;
        for (final ArgumentListIterator iterator = new ArgumentListIterator(template, TestCaseLegality.LEGAL); iterator.hasNext();) {
            final Sequence<Argument> argumentList = iterator.next();
            final Assembler assembler = createTestAssembler();

            final byte[] internalResult;
            try {
              _timer.start("asm");
              assembly().assemble(assembler, template, argumentList);
              internalResult = assembler.toByteArray();
            } finally {
              _timer.stop();
            }

            Trace.line(3, "assembleInternally: " + assembly().createMethodCallString(template, argumentList) + " = " + DisassembledInstruction.toHexString(internalResult));
            if (_components.contains(AssemblyTestComponent.DISASSEMBLER) && template.isDisassemblable() &&
                    !findExcludedDisassemblerTestArgument(template.parameters(), argumentList)) {

              try {
                _timer.start("dis");
                try {
                  testDisassembler(template, argumentList, internalResult);
                } catch (IOException e) {
                  throw new AssemblyException(e.toString());
                }
              } finally {
                _timer.stop();
              }
            }

              if (testingExternally && !findExcludedExternalTestArgument(template.parameters(), argumentList)) {
                final byte[] externalResult = readExternalInstruction(externalInputStream, template, internalResult);
                for (int i = 0; i < externalResult.length; i++) {
                    if (internalResult[i] != externalResult[i]) {
                        System.err.println("external assembler test case " + testCaseNumber + " failed for template: " + template);
                        System.err.println("arguments: " + argumentList);
                        System.err.println("internal result: " + DisassembledInstruction.toHexString(internalResult));
                        System.err.println("external result: " + DisassembledInstruction.toHexString(externalResult));
                        System.err.println("internal result fields: " + disassembleFields(template, internalResult));
                        System.err.println("external result fields: " + disassembleFields(template, externalResult));
                        ProgramError.unexpected("mismatch between internal and external assembler");
                    }
                }
            }
            ++testCaseNumber;
        }

        // Process illegal test cases
        int illegalTestCaseNumber = 0;
        final Set<String> uniqueExceptionMessages = new HashSet<String>();
        for (TestCaseLegality testCaseLegality : new TestCaseLegality[]{TestCaseLegality.ILLEGAL_BY_CONSTRAINT, TestCaseLegality.ILLEGAL_BY_ARGUMENT}) {
            for (final ArgumentListIterator iterator = new ArgumentListIterator(template, testCaseLegality); iterator.hasNext();) {
                final Sequence<Argument> argumentList = iterator.next();
                final Assembler assembler = createTestAssembler();
                try {
                    assembly().assemble(assembler, template, argumentList);
                } catch (IllegalArgumentException e) {
                    final String exceptionMessage = e.getMessage();
                    uniqueExceptionMessages.add(exceptionMessage);
                    ++illegalTestCaseNumber;
                    continue;
                }

                System.err.println("illegal assembler test case " + illegalTestCaseNumber + " did not throw an exception for template: " + template);
                System.err.println("arguments: " + argumentList);
                ProgramError.unexpected("failed illegal test case");
                ++illegalTestCaseNumber;
            }
        }

      Trace.line(2, "template: " + template + "  [" + testCaseNumber + " test cases, " +
                      "timings: " + getTimingString() + ", " +
                      illegalTestCaseNumber + " illegal test cases]");
        for (String message : uniqueExceptionMessages) {
            Trace.line(2, "    caught expected IllegalArgumentException: " + message);
        }
        if (testingExternally) {
            for (int i = 0; i < _nNOPs; i++) {
                if (!readNop(externalInputStream)) {
                    ProgramError.unexpected("end pattern missing in: " + binaryFile.getAbsolutePath());
                }
            }
            externalInputStream.close();
        }
    }

  private StringBuilder getTimingString() {
    final Iterator<Entry<String, Long>> iterator = _timer.flatTimes().iterator();
    boolean hasNext = iterator.hasNext();
    final StringBuilder buf = new StringBuilder();
    while (hasNext) {
      final Entry<String, Long> element = iterator.next();
      final String string = element.getKey() + "=" + element.getValue() + "ms";
      buf.append(string);
      hasNext = iterator.hasNext();
      if (hasNext) {
        buf.append(", ");
      }
    }
    return buf;
  }

  private String _templatePattern;

    /**
     * Sets the pattern that restricts which templates are tested.
     *
     * @param pattern if non-null, only templates whose {@link Template#internalName() name} contains
     *                {@code pattern} as a substring are tested
     */
    public void setTemplatePattern(String pattern) {
        _templatePattern = pattern;
    }

    public void run(int startTemplateSerial, int endTemplateSerial, boolean onlyCreateExternalSource) {
        File sourceFile = null;
        IndentWriter stream = null;
        final AppendableSequence<Template_Type> errors = new ArrayListSequence<Template_Type>();

        try {
            for (Template_Type template : assembly().templates()) {
                if (template.serial() > endTemplateSerial) {
                    break;
                }
                Trace.on(2);
                try {
                    if (template.serial() >= startTemplateSerial) {
                        if (_templatePattern == null || template.internalName().contains(_templatePattern)) {
                            if (onlyCreateExternalSource) {
                                if (sourceFile == null) {
                                    sourceFile = new File(_tmpFilePrefix + "all" + SOURCE_EXTENSION);
                                    stream = new IndentWriter(new PrintWriter(new BufferedWriter(new FileWriter(sourceFile))));
                                    stream.indent();
                                }
                                createExternalSource(template, stream);
                            } else {
                                testTemplate(template);
                            }
                        }
                    }
                } catch (Throwable throwable) {
                    Trace.line(2, "template: " + template + "  failed testing");
                    throwable.printStackTrace();
                    errors.append(template);
                }
            }
        } finally {
            if (onlyCreateExternalSource && stream != null) {
                stream.close();
            }
        }

        if (!errors.isEmpty()) {
            System.err.println("Errors occurred when testing the following templates:");
            for (Template_Type template : errors) {
                System.err.println("    " + template);
            }
            ProgramError.unexpected(errors.length() + " templates failed testing: see previous stack dumps in test output");
        }
    }

    public void run(int startTemplateSerial) {
        run(startTemplateSerial, Integer.MAX_VALUE, false);
    }

    public void run() {
        run(0);
    }

  public static final class Redirector extends Thread {

    private final InputStream _inputStream;
    private final OutputStream _outputStream;
    private final String _name;
    private final int _maxLines;
    private final Process _process;
    private boolean _closed;

    private Redirector(Process process, InputStream inputStream, OutputStream outputStream, String name, int maxLines) {
      _inputStream = inputStream;
      _outputStream = outputStream;
      _name = name;
      _maxLines = maxLines;
      _process = process;
      start();
    }

    public void close() {
      _closed = true;
    }

    @Override
    public void run() {
      try {
        try {
          int line = 1;
          while (!_closed) {
            if (_inputStream.available() == 0) {
              // A busy yielding loop is used so that this thread can be
              // stopped via a call to close() by another thread. Otherwise,
              // this thread could be blocked forever on an input stream
              // that is not closed and does not have any available data.
              // The prime example of course is System.in.
              Thread.yield();
              continue;
            }

            final int b = _inputStream.read();
            if (b < 0) {
              return;
            }
            if (line <= _maxLines) {
              _outputStream.write(b);
            }
            if (b == '\n') {
              if (line == _maxLines) {
                _outputStream.write(("<redirected stream concatenated after " +
                                     _maxLines +
                                     " lines>" +
                                     System.getProperty("line.separator", "\n")).getBytes());
              }
              ++line;
            }
          }
          _outputStream.flush();
        } catch (IOException ioe) {
          try {
            _process.exitValue();

            // This just means the process was terminated and the relevant pipe no longer exists
          } catch (IllegalThreadStateException e) {
            // Some other unexpected IO error occurred -> rethrow
            throw e;
          }
        }
      } catch (Throwable throwable) {
        if (_name != null) {
          System.err.println("Error while redirecting sub-process stream for \"" + _name + "\"");
        }
        throwable.printStackTrace();
      }
    }

  }
}
